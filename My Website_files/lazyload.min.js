!function (name, definition) {
  if (typeof module !== 'undefined' && module.exports) module.exports = definition();
  else if (typeof define === 'function' && define.amd) define(definition);
  else this[name] = definition();
}('LazyLoad', function () {

  'use strict';

  // Configuration
  const defaultConfig = {
    selector: '.lazy',
    container: null,
    threshold: 300,
    thresholds: null,
    dataAttr: 'src',
    dataAttrSet: 'srcset',
    dataAttrSizes: 'sizes',
    dataAttrBG: 'bg',
    dataAttrBGHidpi: 'bg-hidpi',
    dataAttrBGMulti: 'bg-multi',
    dataAttrBGMultiHidpi: 'bg-multi-hidpi',
    dataAttrBGSet: 'bg-set',
    dataAttrPoster: 'poster',
    classApplied: 'applied',
    classLoading: 'loading',
    classLoaded: 'loaded',
    classError: 'error',
    classEntered: 'entered',
    classExited: 'exited',
    unobserveCompleted: true,
    unobserveEntered: false,
    cancelOnExit: true,
    callbackEnter: null,
    callbackExit: null,
    callbackApplied: null,
    callbackLoading: null,
    callbackLoaded: null,
    callbackError: null,
    callbackFinish: null,
    callbackCancel: null,
    useNative: false,
    restoreOnError: false,
  };

  // Helper functions
  function isVisible(element) {
    return !element.hasAttribute('data-ll-status') || element.getAttribute('data-ll-status') === 'loaded';
  }

  function isNative(element) {
    return element.hasAttribute('loading') && element.getAttribute('loading') === 'lazy';
  }

  function getDataStatus(element, status) {
    return element.hasAttribute(`data-ll-status-${status}`);
  }

  function setDataStatus(element, status, value) {
    if (value) {
      element.setAttribute(`data-ll-status-${status}`, '');
    } else {
      element.removeAttribute(`data-ll-status-${status}`);
    }
  }

  function getAttributeValues(element, attributes) {
    return attributes.reduce((values, attribute) => {
      values[attribute] = element.getAttribute(attribute);
      return values;
    }, {});
  }

  function setAttributeValues(element, values) {
    for (let attribute in values) {
      if (values.hasOwnProperty(attribute)) {
        element.setAttribute(attribute, values[attribute]);
      }
    }
  }

  function observeIntersection(entries, config, lazyLoadInstance) {
    entries.forEach(entry => {
      if (entry.isIntersecting || entry.intersectionRatio > 0) {
        if (getDataStatus(entry.target, 'entered')) {
          setDataStatus(entry.target, 'exited', true);
          lazyLoadInstance.cancel(entry.target, 'exit');
        } else {
          setDataStatus(entry.target, 'entered', true);
          lazyLoadInstance.load(entry.target, config);
        }
      }
    });
  }

  // LazyLoad class
  class LazyLoad {
    constructor(config) {
      this.config = Object.assign({}, defaultConfig, config);
      this.instances = [];
      this.update();

      if (this.config.container) {
        this.observer = new IntersectionObserver(entries => observeIntersection(entries, this.config, this), {
          root: this.config.container === document ? null : this.config.container,
          rootMargin: this.config.thresholds || `${this.config.threshold}px`,
        });
      }

      if (this.config.restoreOnError) {
        window.addEventListener('online', this.restore.bind(this));
      }
    }

    update(config) {
      if (config) {
        this.config = Object.assign({}, this.config, config);
      }

      this.instances = Array.from(this.config.container.querySelectorAll(this.config.selector))
        .filter(element => !isNative(element) && !isVisible(element));

      this.observer.disconnect();

      if (this.config.container) {
        this.observer = new IntersectionObserver(entries => observeIntersection(entries, this.config, this), {
          root: this.config.container === document ? null : this.config.container,
          rootMargin: this.config.thresholds || `${this.config.threshold}px`,
        });
      }

      this.observer.observe(...this.instances);
    }

    destroy() {
      this.observer.disconnect();
      window.removeEventListener('online', this.restore.bind(this));
      this.instances.forEach(element => {
        element.removeAttribute('data-ll-status');
        element.removeAttribute('data-ll-status-entered');
        element.removeAttribute('data-ll-status-exited');
      });
      delete this.observer;
      delete this.config;
      delete this.instances;
    }

    load(element, config) {
      const data = getAttributeValues(element, [
        config.dataAttr,
        config.dataAttrSet,
        config.dataAttrSizes,
        config.dataAttrBG,
        config.dataAttrBGHidpi,
        config.dataAttrBGMulti,
        config.dataAttrBGMultiHidpi,
        config.dataAttrBGSet,
        config.dataAttrPoster,
      ]);

      const observer = new IntersectionObserver(entries => {
        if (entries[0].isIntersecting || entries[0].intersectionRatio > 0) {
          element.removeAttribute('loading');
          setAttributeValues(element, {
            src: data[config.data
