!function (name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition();
  else if (typeof define == 'function' && define.amd) define(definition);
  else this[name] = definition();
}('LazyLoad', function () {

  'use strict';

  // Configuration
  const defaultConfig = {
    elements_selector: '.lazy',
    container: null,
    threshold: 300,
    thresholds: null,
    data_src: 'src',
    data_srcset: 'srcset',
    data_sizes: 'sizes',
    data_bg: 'bg',
    data_bg_hidpi: 'bg-hidpi',
    data_bg_multi: 'bg-multi',
    data_bg_multi_hidpi: 'bg-multi-hidpi',
    data_bg_set: 'bg-set',
    data_poster: 'poster',
    class_applied: 'applied',
    class_loading: 'loading',
    class_loaded: 'loaded',
    class_error: 'error',
    class_entered: 'entered',
    class_exited: 'exited',
    unobserve_completed: true,
    unobserve_entered: false,
    cancel_on_exit: true,
    callback_enter: null,
    callback_exit: null,
    callback_applied: null,
    callback_loading: null,
    callback_loaded: null,
    callback_error: null,
    callback_finish: null,
    callback_cancel: null,
    use_native: false,
    restore_on_error: false,
  };

  // Helper functions
  function isVisible(element) {
    return !element.hasAttribute('data-ll-status') || element.getAttribute('data-ll-status') === 'loaded';
  }

  function isNative(element) {
    return element.hasAttribute('loading') && element.getAttribute('loading') === 'lazy';
  }

  function getDataStatus(element, status) {
    return element.hasAttribute(`data-ll-status-${status}`);
  }

  function setDataStatus(element, status, value) {
    if (value) {
      element.setAttribute(`data-ll-status-${status}`, '');
    } else {
      element.removeAttribute(`data-ll-status-${status}`);
    }
  }

  function getAttributeValues(element, attributes) {
    return attributes.reduce((values, attribute) => {
      values[attribute] = element.getAttribute(attribute);
      return values;
    }, {});
  }

  function setAttributeValues(element, values) {
    for (let attribute in values) {
      if (values.hasOwnProperty(attribute)) {
        element.setAttribute(attribute, values[attribute]);
      }
    }
  }

  function observeIntersection(entries, config, lazyLoadInstance) {
    entries.forEach(entry => {
      if (entry.isIntersecting || entry.intersectionRatio > 0) {
        if (getDataStatus(entry.target, 'entered')) {
          setDataStatus(entry.target, 'exited', true);
          lazyLoadInstance.cancel(entry.target, 'exit');
        } else {
          setDataStatus(entry.target, 'entered', true);
          lazyLoadInstance.load(entry.target, config);
        }
      }
    });
  }

  // LazyLoad class
  class LazyLoad {
    constructor(config) {
      this.config = Object.assign({}, defaultConfig, config);
      this.instances = [];
      this.update();

      if (this.config.container) {
        this.observer = new IntersectionObserver(entries => observeIntersection(entries, this.config, this), {
          root: this.config.container === document ? null : this.config.container,
          rootMargin: this.config.thresholds || this.config.threshold + 'px',
        });
      }

      if (this.config.restore_on_error) {
        window.addEventListener('online', this.restore.bind(this));
      }
    }

    update(config) {
      if (config) {
        this.config = Object.assign({}, this.config, config);
      }

      this.instances = Array.from(this.config.container.querySelectorAll(this.config.elements_selector))
        .filter(element => !isNative(element) && !isVisible(element));

      this.observer.disconnect();

      if (this.config.container) {
        this.observer = new IntersectionObserver(entries => observeIntersection(entries, this.config, this), {
          root: this.config.container === document ? null : this.config.container,
          rootMargin: this.config.thresholds || this.config.threshold + 'px',
        });
      }

      this.observer.observe(...this.instances);
    }

    destroy() {
      this.observer.disconnect();
      window.removeEventListener('online', this.restore.bind(this));
      this.instances.forEach(element => {
        element.removeAttribute('data-ll-status');
        element.removeAttribute('data-ll-status-entered');
        element.removeAttribute('data-ll-status-exited');
      });
      delete this.observer;
      delete this.config;
      delete this.instances;
    }

    load(element, config) {
      const data = getAttributeValues(element, ['src', 'srcset', 'sizes', 'bg', 'bg-hidpi', 'bg-multi', 'bg-multi-hidpi', 'bg-set', 'poster']);
      const observer = new IntersectionObserver(entries => {
        if (entries[0].isIntersecting || entries[0].intersectionRatio > 0) {
          element.removeAttribute('loading');
          element.src = data[config.data_src];
          element.srcset =
